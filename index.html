<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩しゲーム</title>
<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: sans-serif;
    text-align: center;
  }
  canvas {
    display: none;
    margin: 0 auto;
    background: #000;
  }
  #titleScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: #000;
  }
</style>
</head>
<body>
<div id="titleScreen">
  <h1>ブロック崩しゲーム</h1>
  <button id="startButton">スタート</button>
</div>
<canvas id="gameCanvas" width="480" height="320"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const titleScreen = document.getElementById('titleScreen');
const startButton = document.getElementById('startButton');
let animationId;

const paddleHeight = 10;
let paddleWidth = 75; // Changed to let
let originalPaddleWidth = paddleWidth; // Added
let paddleX = (canvas.width-paddleWidth)/2;
const paddleColor = '#0095DD';

// Wider Paddle power-up variables
let widerPaddleTimer = null;
const WIDER_PADDLE_DURATION = 10000; // 10 seconds in milliseconds
const PADDLE_WIDTH_INCREASE_FACTOR = 1.5;

const ballRadius = 8; // Remains constant
const ballColor = '#FF5733'; // Remains constant
let balls = []; // Array to hold all ball objects

let rightPressed = false;
let leftPressed = false;

const brickRowCount = 5;
const brickColumnCount = 7;
const brickWidth = 55;
const brickHeight = 20;
const brickPadding = 10;
const brickOffsetTop = 30;
const brickOffsetLeft = 35;
const brickColor = '#00FF80';

let score = 0;

// Power-up constants
const POWER_UP_SPAWN_CHANCE = 0.25; // 25% chance
const POWER_UP_WIDTH = 15;
const POWER_UP_HEIGHT = 15;
const POWER_UP_SPEED = 1.5;
const POWER_UP_TYPES = { WIDER_PADDLE: 'wider_paddle', MULTI_BALL: 'multi_ball' };
const POWER_UP_COLORS = { [POWER_UP_TYPES.WIDER_PADDLE]: '#4CAF50', [POWER_UP_TYPES.MULTI_BALL]: '#FFC107' };
let activePowerUps = [];

// Particle class
class Particle {
  constructor(x, y, dx, dy, size, color, life) {
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.size = size;
    this.color = color;
    this.life = life;
    this.maxLife = life; // Store initial life
  }
}

function drawParticles() {
  for (const p of particles) {
    const opacity = p.life / p.maxLife;
    ctx.globalAlpha = opacity;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1.0; // Reset globalAlpha
}

// Particles array
const particles = [];

const bricks = [];
function initBricks() {
  for(let c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(let r=0; r<brickRowCount; r++) {
      bricks[c][r] = { x: 0, y: 0, status: 1 };
    }
  }
}
initBricks();

function initGame() {
  paddleX = (canvas.width - paddleWidth) / 2;
  score = 0;
  rightPressed = false;
  leftPressed = false;
  activePowerUps.length = 0; // Clear active power-ups
  initBricks();

  balls.length = 0; // Clear existing balls
  balls.push({
    x: canvas.width / 2,
    y: canvas.height - 30,
    dx: 2,
    dy: -2,
    radius: ballRadius
  });

  paddleWidth = originalPaddleWidth; // Reset paddle width
  if (widerPaddleTimer) { // Clear active timer
    clearTimeout(widerPaddleTimer);
    widerPaddleTimer = null;
  }
}

function showTitle() {
  if (animationId) {
    cancelAnimationFrame(animationId);
  }
  initGame();
  activePowerUps.length = 0; // Clear active power-ups
  balls.length = 0; // Clear balls when returning to title
  paddleWidth = originalPaddleWidth; // Reset paddle width
  if (widerPaddleTimer) { // Clear active timer
    clearTimeout(widerPaddleTimer);
    widerPaddleTimer = null;
  }
  canvas.style.display = 'none';
  titleScreen.style.display = 'flex';
}

function startGame() {
  initGame();
  titleScreen.style.display = 'none';
  canvas.style.display = 'block';
  draw();
}

startButton.addEventListener('click', startGame);

function keyDownHandler(e) {
  if(e.key === 'Right' || e.key === 'ArrowRight') {
    rightPressed = true;
  } else if(e.key === 'Left' || e.key === 'ArrowLeft') {
    leftPressed = true;
  }
}

function keyUpHandler(e) {
  if(e.key === 'Right' || e.key === 'ArrowRight') {
    rightPressed = false;
  } else if(e.key === 'Left' || e.key === 'ArrowLeft') {
    leftPressed = false;
  }
}

document.addEventListener('keydown', keyDownHandler, false);
document.addEventListener('keyup', keyUpHandler, false);

function spawnPowerUp(brickX, brickY, brickWidth, brickHeight) {
  if (Math.random() < POWER_UP_SPAWN_CHANCE) {
    const powerUpTypesArray = Object.values(POWER_UP_TYPES);
    const selectedType = powerUpTypesArray[Math.floor(Math.random() * powerUpTypesArray.length)];
    const powerUp = {
      type: selectedType,
      x: brickX + brickWidth / 2 - POWER_UP_WIDTH / 2,
      y: brickY + brickHeight / 2 - POWER_UP_HEIGHT / 2,
      width: POWER_UP_WIDTH,
      height: POWER_UP_HEIGHT,
      color: POWER_UP_COLORS[selectedType]
    };
    activePowerUps.push(powerUp);
  }
}

function collisionDetection() {
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        const b = bricks[c][r];
        if(b.status === 1) {
          if(ball.x > b.x && ball.x < b.x+brickWidth && ball.y > b.y && ball.y < b.y+brickHeight) {
            ball.dy = -ball.dy;
            b.status = 0;
            score++;
            spawnPowerUp(b.x, b.y, brickWidth, brickHeight);

            // Create particles
            const brickCenterX = b.x + brickWidth / 2;
          const brickCenterY = b.y + brickHeight / 2;
          for (let i = 0; i < 12; i++) { // Increased particle count
            let pDx = (Math.random() - 0.5) * 4;
            let pDy = (Math.random() - 0.5) * 4;
            if (pDx === 0 && pDy === 0) {
                pDx = 1;
            }
            const pSize = Math.random() * 2 + 2;
            const pLife = Math.random() * 20 + 30; // Increased particle life (30-50)
            particles.push(new Particle(brickCenterX, brickCenterY, pDx, pDy, pSize, brickColor, pLife));
          }

            if(score === brickRowCount*brickColumnCount) {
              cancelAnimationFrame(animationId);
              alert('おめでとう！ 全てのブロックを破壊しました！');
              showTitle();
              return; // Exit early as game is won
            }
          }
        }
      }
    }
  }
}

function drawBalls() { // Renamed from drawBall
  for (const ball of balls) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fillStyle = ballColor; // Assuming ballColor is still global
    ctx.fill();
    ctx.closePath();
  }
}

function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = paddleColor;
  ctx.fill();
  ctx.closePath();
}

function drawBricks() {
  for(let c=0; c<brickColumnCount; c++) {
    for(let r=0; r<brickRowCount; r++) {
      if(bricks[c][r].status === 1) {
        const brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
        const brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = brickColor;
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}

function drawScore() {
  ctx.font = '16px Arial';
  ctx.fillStyle = '#ffffff';
  ctx.fillText('Score: '+score, 8, 20);
}

function drawPowerUps() {
  for (const powerUp of activePowerUps) {
    ctx.fillStyle = powerUp.color;
    ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
    ctx.fillStyle = '#000'; // Text color
    ctx.font = '10px Arial';
    let text = '';
    if (powerUp.type === POWER_UP_TYPES.WIDER_PADDLE) text = 'W';
    else if (powerUp.type === POWER_UP_TYPES.MULTI_BALL) text = 'M';
    ctx.fillText(text, powerUp.x + POWER_UP_WIDTH / 2 - ctx.measureText(text).width / 2, powerUp.y + POWER_UP_HEIGHT / 2 + 3);
  }
}

function updatePowerUps() {
  for (let i = activePowerUps.length - 1; i >= 0; i--) {
    const p = activePowerUps[i];
    p.y += POWER_UP_SPEED;

    // Collision with paddle
    if (p.x < paddleX + paddleWidth &&
        p.x + p.width > paddleX &&
        p.y < canvas.height &&
        p.y + p.height > canvas.height - paddleHeight) {

      if (p.type === POWER_UP_TYPES.WIDER_PADDLE) {
        paddleWidth = originalPaddleWidth * PADDLE_WIDTH_INCREASE_FACTOR;
        if (widerPaddleTimer) {
          clearTimeout(widerPaddleTimer);
        }
        widerPaddleTimer = setTimeout(() => {
          paddleWidth = originalPaddleWidth;
          widerPaddleTimer = null;
        }, WIDER_PADDLE_DURATION);
      } else if (p.type === POWER_UP_TYPES.MULTI_BALL) {
        if (balls.length > 0 && balls.length < 5) { // Limit max balls e.g. to 5
          const originalBall = balls[0]; // Or a random one
          const newBall = {
            x: originalBall.x,
            y: originalBall.y - originalBall.radius - 1, // Start slightly offset
            dx: -originalBall.dx, // Reverse horizontal direction
            dy: originalBall.dy * (Math.random() > 0.5 ? 1 : -1), // Vary vertical slightly
            radius: ballRadius
          };
          if (newBall.dy === 0) newBall.dy = -2; // Ensure it moves vertically
          balls.push(newBall);
        }
      }

      activePowerUps.splice(i, 1); // Remove collected power-up
      continue; // Skip to next power-up as this one is removed
    }

    // Remove if off-screen
    if (p.y > canvas.height) {
      activePowerUps.splice(i, 1);
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBalls(); // Changed from drawBall()
  drawPaddle();
  drawScore();
  drawPowerUps(); // Draw power-ups
  drawParticles(); // Draw particles after score and other elements
  collisionDetection();
  updatePowerUps(); // Update power-up positions
  updateParticles();

  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];

    // Wall Collisions
    if(ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
      ball.dx = -ball.dx;
    }
    if(ball.y + ball.dy < ball.radius) {
      ball.dy = -ball.dy;
    }
    // Paddle Collision & Loss Condition
    else if(ball.y + ball.dy > canvas.height - ball.radius - paddleHeight) { // Check if near paddle height
      if (ball.y + ball.dy > canvas.height - ball.radius) { // Actually below paddle top edge
        if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
          ball.dy = -ball.dy;
          // Optional: Adjust dy to prevent sticking or multiple hits if ball is too deep
          // ball.y = canvas.height - paddleHeight - ball.radius;
        } else {
          balls.splice(i, 1); // Remove this ball
        }
      }
    }

    // Update ball position
    ball.x += ball.dx;
    ball.y += ball.dy;
  }

  if (balls.length === 0) {
    cancelAnimationFrame(animationId);
    alert('ゲームオーバー');
    showTitle();
    return; // Important to stop further drawing in this frame
  }

  if(rightPressed && paddleX < canvas.width-paddleWidth) {
    paddleX += 5;
  } else if(leftPressed && paddleX > 0) {
    paddleX -= 5;
  }

  animationId = requestAnimationFrame(draw);
}

showTitle();
</script>
</body>
</html>
